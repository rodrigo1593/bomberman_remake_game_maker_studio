<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Important stuff about making the analog stick work properly!

/* 
    The stick is drawn to the GUI layer - that is, its pixels aren't scaled up with the game view. 
    It is drawn DIRECTLY to the screen. This means that if you have (on Windows Phone, for instance) a 400x200 game that 
    is scaled up to a 1280x720 resolution, the analog stick will be drawn as if the game wasn't scaled. (If the stick 
    was positioned at (380,180), the lower-left of a 400x200 screen, it would appear to be in the upper right of a 
    1280x720 screen.)
    So be mindful of how the coordinates at which you place the analog stick in the room editor may not necessarily 
    reflect the coordinates to which it is drawn during run time!  
    
    Currently there's code in the stick's create event to take care of this issue (it's as simple as multiplying its room
    coordinates by the ratio of the screen width to the view width), but it's a good thing to be aware of. 
    HOWEVER, make sure your room has at least one view, even if your game doesn't need it! 
    (Using the variables view_wview and view_hview when views aren't actually enabled doesn't seem to work. 
    To work around this, just make a view with the dimensions of your room. Thanks!)
*/
        
        
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialize enums for axes

// originally these were stored as AXIS_X and AXIS_Y 
// as macros/constants, but the marketplace currently 
// doesn't support those. 

enum axis { 
    X,
    Y
}; 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialize stick

boundSprite = sprite_index; // should be spr_analog_boundary 
stickSprite = spr_analog_stick; 

radius = sprite_get_width(boundSprite)/2; 
alpha = 0.75; 
snapRate = 24; // speed at which stick snapes back to origin

// as a note, image_xscale and image_yscale should be used for referencing scale.

// stick OBJECT won't actually move with view - only sprite will. 
guiX = x * display_get_gui_width()/view_wview; // multiplying by the gui to room ratio accounts for any view scaling issues
guiY = y * display_get_gui_height()/view_hview;

// using GUI mouse coordinates is easier than offsetting the room
guiMouseX = device_mouse_x_to_gui(0); 
guiMouseY = device_mouse_y_to_gui(0); 

stickX = guiX; 
stickY = guiY; 

// boolean
isPressed = false; 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// update analog stick

if (device_mouse_check_button(0,mb_left)) { 
    isPressed = true; 
    
    // update GUI mouse coords only if mouse is pressed
    guiMouseX = device_mouse_x_to_gui(0); 
    guiMouseY = device_mouse_y_to_gui(0); 
}
else { 
    isPressed = false; 
}

// update stick coords
if (isPressed) { 
    if (point_distance(guiX,guiY,guiMouseX,guiMouseY) &lt;= radius*image_xscale) {
        stickX = guiMouseX; 
        stickY = guiMouseY;
    }
    else { // constrain stick to boundary
        var dir = point_direction(guiX,guiY,guiMouseX,guiMouseY); 
        stickX = guiX + lengthdir_x(radius*image_xscale,dir); 
        stickY = guiY + lengthdir_y(radius*image_xscale,dir); 
    }
}
else { 
    // snap back to origin
    if (point_distance(stickX,stickY,guiX,guiY) &gt;= snapRate*image_xscale) {
        var dir = point_direction(stickX,stickY,guiX,guiY); 
        stickX += lengthdir_x(snapRate*image_xscale,dir); 
        stickY += lengthdir_y(snapRate*image_xscale,dir); 
    }
    else { // prevents overshooting
        stickX = guiX; 
        stickY = guiY; 
    }       
}
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw the stick

draw_sprite_ext(boundSprite,0,guiX,guiY,image_xscale,image_yscale,0,c_white,alpha); 

// stick
draw_sprite_ext(stickSprite,0,stickX,stickY,image_xscale,image_yscale,0,c_white,alpha); 


// debug

var axisx = scr_get_analog_stick_axis(self,axis.X); 
var axisy = scr_get_analog_stick_axis(self,axis.Y); 

draw_text(32,32,"x: "+string(axisx)+"#y: "+string(axisy)); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// override draw_self() so that only GUI renders
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>128,128</point>
    <point>128,128</point>
  </PhysicsShapePoints>
</object>
